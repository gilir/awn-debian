/* labelled-separator.c generated by valac 0.10.4, the Vala compiler
 * generated from labelled-separator.vala, do not modify */

/*
 * Copyright (C) 2010 Michal Hruby <michal.mhr@gmail.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authored by Michal Hruby <michal.mhr@gmail.com>
 *
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <pango/pango.h>


#define TASK_MANAGER_TYPE_LABELLED_SEPARATOR (task_manager_labelled_separator_get_type ())
#define TASK_MANAGER_LABELLED_SEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TASK_MANAGER_TYPE_LABELLED_SEPARATOR, TaskManagerLabelledSeparator))
#define TASK_MANAGER_LABELLED_SEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TASK_MANAGER_TYPE_LABELLED_SEPARATOR, TaskManagerLabelledSeparatorClass))
#define TASK_MANAGER_IS_LABELLED_SEPARATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TASK_MANAGER_TYPE_LABELLED_SEPARATOR))
#define TASK_MANAGER_IS_LABELLED_SEPARATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TASK_MANAGER_TYPE_LABELLED_SEPARATOR))
#define TASK_MANAGER_LABELLED_SEPARATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TASK_MANAGER_TYPE_LABELLED_SEPARATOR, TaskManagerLabelledSeparatorClass))

typedef struct _TaskManagerLabelledSeparator TaskManagerLabelledSeparator;
typedef struct _TaskManagerLabelledSeparatorClass TaskManagerLabelledSeparatorClass;
typedef struct _TaskManagerLabelledSeparatorPrivate TaskManagerLabelledSeparatorPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

struct _TaskManagerLabelledSeparator {
	GtkSeparatorMenuItem parent_instance;
	TaskManagerLabelledSeparatorPrivate * priv;
};

struct _TaskManagerLabelledSeparatorClass {
	GtkSeparatorMenuItemClass parent_class;
};

struct _TaskManagerLabelledSeparatorPrivate {
	GtkLabel* label_widget;
};


static gpointer task_manager_labelled_separator_parent_class = NULL;

GType task_manager_labelled_separator_get_type (void) G_GNUC_CONST;
#define TASK_MANAGER_LABELLED_SEPARATOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TASK_MANAGER_TYPE_LABELLED_SEPARATOR, TaskManagerLabelledSeparatorPrivate))
enum  {
	TASK_MANAGER_LABELLED_SEPARATOR_DUMMY_PROPERTY
};
TaskManagerLabelledSeparator* task_manager_labelled_separator_new (const char* text);
TaskManagerLabelledSeparator* task_manager_labelled_separator_construct (GType object_type, const char* text);
static GType task_manager_labelled_separator_real_child_type (GtkContainer* base);
static gboolean task_manager_labelled_separator_real_expose_event (GtkWidget* base, GdkEventExpose* event);
static void task_manager_labelled_separator_finalize (GObject* obj);



TaskManagerLabelledSeparator* task_manager_labelled_separator_construct (GType object_type, const char* text) {
	TaskManagerLabelledSeparator * self = NULL;
	GtkWidget* _tmp0_;
	g_return_val_if_fail (text != NULL, NULL);
	self = (TaskManagerLabelledSeparator*) g_object_new (object_type, "label", text, NULL);
	self->priv->label_widget = (_tmp0_ = gtk_bin_get_child ((GtkBin*) self), GTK_IS_LABEL (_tmp0_) ? ((GtkLabel*) _tmp0_) : NULL);
	gtk_misc_set_alignment ((GtkMisc*) self->priv->label_widget, 0.5f, 0.5f);
	return self;
}


TaskManagerLabelledSeparator* task_manager_labelled_separator_new (const char* text) {
	return task_manager_labelled_separator_construct (TASK_MANAGER_TYPE_LABELLED_SEPARATOR, text);
}


static GType task_manager_labelled_separator_real_child_type (GtkContainer* base) {
	TaskManagerLabelledSeparator * self;
	GType result = 0UL;
	self = (TaskManagerLabelledSeparator*) base;
	result = GTK_TYPE_WIDGET;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gboolean task_manager_labelled_separator_real_expose_event (GtkWidget* base, GdkEventExpose* event) {
	TaskManagerLabelledSeparator * self;
	gboolean result = FALSE;
	gboolean wide_separators = FALSE;
	gint separator_height = 0;
	gint horizontal_padding = 0;
	GtkAllocation alloc = {0};
	gint xthickness;
	gint ythickness;
	GtkAllocation child_alloc = {0};
	GtkWidget* _tmp0_;
	PangoLayout* layout;
	PangoRectangle rect = {0};
	GtkWidget* parent;
	gint x = 0;
	gint y = 0;
	self = (TaskManagerLabelledSeparator*) base;
	gtk_widget_get_allocation ((GtkWidget*) self, &alloc);
	gtk_widget_style_get ((GtkWidget*) self, "wide-separators", &wide_separators, "separator-height", &separator_height, "horizontal-padding", &horizontal_padding, NULL, NULL);
	xthickness = gtk_widget_get_style ((GtkWidget*) self)->xthickness;
	ythickness = gtk_widget_get_style ((GtkWidget*) self)->ythickness;
	if (wide_separators) {
		gtk_paint_box (gtk_widget_get_style ((GtkWidget*) self), gtk_widget_get_window ((GtkWidget*) self), GTK_STATE_NORMAL, GTK_SHADOW_ETCHED_OUT, &(*event).area, (GtkWidget*) self, "hseparator", (alloc.x + horizontal_padding) + xthickness, alloc.y + (((alloc.height - separator_height) - ythickness) / 2), alloc.width - (2 * (horizontal_padding + xthickness)), separator_height);
	} else {
		gtk_paint_hline (gtk_widget_get_style ((GtkWidget*) self), gtk_widget_get_window ((GtkWidget*) self), GTK_STATE_NORMAL, &(*event).area, (GtkWidget*) self, "menuitem", (alloc.x + horizontal_padding) + xthickness, (((alloc.x + alloc.width) - horizontal_padding) - xthickness) - 1, alloc.y + ((alloc.height - ythickness) / 2));
	}
	gtk_widget_get_allocation (gtk_bin_get_child ((GtkBin*) self), &child_alloc);
	layout = _g_object_ref0 (gtk_label_get_layout ((_tmp0_ = gtk_bin_get_child ((GtkBin*) self), GTK_IS_LABEL (_tmp0_) ? ((GtkLabel*) _tmp0_) : NULL)));
	pango_layout_get_pixel_extents (layout, NULL, &rect);
	parent = gtk_widget_get_parent ((GtkWidget*) self);
	x = (child_alloc.width - rect.width) / 2;
	y = (child_alloc.height - rect.height) / 2;
	gtk_paint_flat_box (gtk_widget_get_style (parent), gtk_widget_get_window ((GtkWidget*) self), GTK_STATE_NORMAL, GTK_SHADOW_NONE, NULL, (GtkWidget*) self, NULL, child_alloc.x + x, child_alloc.y + y, rect.width, rect.height);
	gtk_container_propagate_expose ((GtkContainer*) self, gtk_bin_get_child ((GtkBin*) self), event);
	result = TRUE;
	_g_object_unref0 (layout);
	return result;
}


static void task_manager_labelled_separator_class_init (TaskManagerLabelledSeparatorClass * klass) {
	task_manager_labelled_separator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (TaskManagerLabelledSeparatorPrivate));
	GTK_CONTAINER_CLASS (klass)->child_type = task_manager_labelled_separator_real_child_type;
	GTK_WIDGET_CLASS (klass)->expose_event = task_manager_labelled_separator_real_expose_event;
	G_OBJECT_CLASS (klass)->finalize = task_manager_labelled_separator_finalize;
}


static void task_manager_labelled_separator_instance_init (TaskManagerLabelledSeparator * self) {
	self->priv = TASK_MANAGER_LABELLED_SEPARATOR_GET_PRIVATE (self);
}


static void task_manager_labelled_separator_finalize (GObject* obj) {
	TaskManagerLabelledSeparator * self;
	self = TASK_MANAGER_LABELLED_SEPARATOR (obj);
	G_OBJECT_CLASS (task_manager_labelled_separator_parent_class)->finalize (obj);
}


GType task_manager_labelled_separator_get_type (void) {
	static volatile gsize task_manager_labelled_separator_type_id__volatile = 0;
	if (g_once_init_enter (&task_manager_labelled_separator_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (TaskManagerLabelledSeparatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) task_manager_labelled_separator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TaskManagerLabelledSeparator), 0, (GInstanceInitFunc) task_manager_labelled_separator_instance_init, NULL };
		GType task_manager_labelled_separator_type_id;
		task_manager_labelled_separator_type_id = g_type_register_static (GTK_TYPE_SEPARATOR_MENU_ITEM, "TaskManagerLabelledSeparator", &g_define_type_info, 0);
		g_once_init_leave (&task_manager_labelled_separator_type_id__volatile, task_manager_labelled_separator_type_id);
	}
	return task_manager_labelled_separator_type_id__volatile;
}




